---
title: "HW5"
author: "Bedros, Haig; Dela Cruz, Sandra; Hugh, Tiffany; Li, Yanyi"
date: "`r Sys.Date()`"
output:
editor_options: 
  markdown: 
    wrap: 72
---
<style type="text/css">

h1.title {
  font-size: 26px;
  color: Black;
  text-align: center;
}
h4.author { 
  font-size: 18px;
  color: Black;
  text-align: center;
}
h4.date {
  font-size: 12px;
  color: Black;
  text-align: center;
}
</style>
```{r setup, include=FALSE}
knitr::opts_chunk$set(tidy.opts = list(width.cutoff = 50), tidy = TRUE, warning = FALSE)
```

```{r, include=FALSE}
# Load required packages
library(dplyr)
library(stringr)
library(ggplot2)
library(tidyr)
library(purrr)
library(DataExplorer)
library(reshape2)
library(pROC)
library(readr)
library(caret)
library(DHARMa)
library(lares)
library(mice)
library(gridExtra)

# Import dataset
wine_training_data <- read_csv("https://raw.githubusercontent.com/tiffhugh/DATA-621/refs/heads/main/Assignment%20%235/wine-training-data.csv")
wine_evaluation_data<- read_csv("https://raw.githubusercontent.com/tiffhugh/DATA-621/refs/heads/main/Assignment%20%235/wine-evaluation-data.csv")
```

# **Data Exploration**
First, let's remove the 'INDEX' column in both of the dataset, since we are not going to need it.
```{r, echo=FALSE}
# remove index columns
wine_training_data <- wine_training_data %>% select(-INDEX)
glimpse(wine_training_data)
dim(wine_training_data)

# do the same for evaluation data
wine_evaluation_data <- wine_evaluation_data %>% select(-IN)
```
Our wine training dataset has 12,795 observations and 15 columns. As we can see, there are a lot of data transformations that needs to be done with our variables, like cleaning our values and changing the columns into categorical values, like for `LabelAppeal` and `STARS`.

### Data Transformation of Variables
First, we clean the data by removing leading hyphens (-) from numeric values, as chemical concentrations cannot be negative, and such entries likely result from formatting errors.
```{r, echo=FALSE}
# clean the values in our variables by removing hyphens
wine_training_data <- wine_training_data %>% 
  mutate(across(-LabelAppeal, ~gsub("-", "", .x)))
glimpse(wine_training_data)

wine_evaluation_data <- wine_evaluation_data %>%
  mutate(across(-LabelAppeal, ~gsub("-", "", .x)))
```
Now that we have removed unnecessary characters in our values, let's review our distinct values.
```{r, echo=FALSE}
# check distinct values for all columns
wine_training_data %>% summarise(across(everything(), ~n_distinct(.)))

# check unique values in possibly ordinal columns
wine_training_data %>% 
  distinct(LabelAppeal, STARS) %>% 
  map(~unique(.))
```
As we can see, 'NA' is present for the `STARS` column. Later we'll impute those with values using "polr" from the MICE package, considering it's a ordinal categorical column.

Now, let's proceed with converting our columns to the appropriate data types, such as numeric, or ordinal variables:
Convert to numeric variables: `TARGET`, `FixedAcidity`, `VolatileAcidity`, `CitricAcid`, `ResidualSugar`, `Chlorides`, `FreeSulfurDioxide`, `TotalSulfurDioxide`, `Density`, `pH`, `Sulphates`, `Alcohol`, `AcidIndex`
Convert to ordinal variables: `STARS`, `LabelAppeal`
```{r, echo=FALSE}
wine_training_data <- wine_training_data %>% 
  mutate(
    # convert all numeric variables
    across(c(TARGET, FixedAcidity, VolatileAcidity, CitricAcid, 
             ResidualSugar, Chlorides, FreeSulfurDioxide, TotalSulfurDioxide, 
             Density, pH, Sulphates, Alcohol, AcidIndex), as.numeric),
    # convert all ordinal variables
    across(c(STARS, LabelAppeal), as.ordered)
  )

glimpse(wine_training_data)

# do the same for evaluation data
wine_evaluation_data <- wine_evaluation_data %>% 
  mutate(
    # convert all numeric variables
    across(c(TARGET, FixedAcidity, VolatileAcidity, CitricAcid, 
             ResidualSugar, Chlorides, FreeSulfurDioxide, TotalSulfurDioxide, 
             Density, pH, Sulphates, Alcohol, AcidIndex), as.numeric),
    # convert all ordinal variables
    across(c(STARS, LabelAppeal), as.ordered)
  )
```
### Summary of Datasets
In our dataset, missing values (NA) appear in variables such as `ResidualSugar`, `Chlorides`, `FreeSulfurDioxide`, `TotalSulfurDioxide`, `pH`, `Sulphates`, `Alcohol`, and `STARS`. We plan to address these through appropriate imputation techniques, including median imputation, Predictive Mean Matching (PPM) for continuous variables, or proportional odds logistic regression (polr) via the `mice` package for ordinal categorical variables like STARS, depending on variable distribution.

From our summary, some extreme values also warrant attention. For instance, `FixedAcidity` values greater than 16 g/L are chemically improbable, as white wines typically range between 4–10 g/L and red wines 4–16 g/L. For `FreeSulfurDioxide`, values exceeding 350 mg/L surpass US regulatory limits, and EU limits are even lower (~150 mg/L). Given the lack of country-specific data, we'll apply US thresholds. Similar logic applies to `TotalSulfurDioxide`.

We will flag values that exceed these thresholds, treat them as missing, and impute accordingly to reduce bias and ensure realistic modeling.

However, for variables like `ResidualSugar`, `Density`, and `Alcohol`, we'll retain outliers—such as those seen in sweet and fortified wines (e.g., Tokaji, Sherry)—as they represent valid cases. We'll reassess how best to impute missing values in variables such as `pH`, `Sulphates`, `Alcohol`, `ResidualSugar`, and `Chlorides`.
```{r, echo=FALSE}
#| fig-height: 3
#| fig-width: 8
cat("Summary of training data: \n")
summary(wine_training_data)
```
### Plots for Visual Assesment
Below we can see that most of our variables are skewed to the right, only `ph` and `Density` are somewhat normally distributed.
```{r, echo=FALSE}
#| fig-height: 5
#| fig-width: 10
cat("Histogram of training data: \n")
plot_histogram(wine_training_data)
cat("Density Plot of training data: \n")
plot_density(wine_training_data)
cat("Boxplot of training data: \n")
plot_boxplot(wine_training_data, by='TARGET')
cat("Barplot of training data: \n")
plot_bar(wine_training_data)
```
### Visual Correlation of Variables
```{r, echo=FALSE, message=FALSE}
#| fig-height: 5
#| fig-width: 10
corr_cross(wine_training_data, 
           method = "spearman", max_pvalue = 0.05, top = 20)

corr_cross(wine_training_data, 
           method = "spearman", max_pvalue = 0.05, 
           contains = c('TARGET'))
```
To visualize correlations, we use the `corr_cross()` function from the `lares` package, which allows for an easy comparison across variables. We set the method to Spearman because most of our data is not normally distributed.

From the resulting graphs, we observe that `TARGET` and `STARS_NAs` are strongly negatively correlated, though, as mentioned earlier, we will impute missing values for `STARS` later on.

Additionally, we note a correlation between `TARGET` and `STARS_3`, but the p-value is 0.377, indicating no statistically significant relationship, so it's not a concern for our analysis.

With these insights, we're ready to move forward with the data preparation phase.

# **Data Preparation**
### Replace Extreme Variables With NA
First, let's replace the extreme values from the certain variables that we have:
Threshold of `FixedAcidity`: 16 g/L
Threshold of `FreeSulfurDioxide`: 350 mg/L
Threshold of `TotalSulfurDioxide`: 350 mg/L

```{r, echo=FALSE}

wine_training_data <- wine_training_data %>%
  mutate(
    FixedAcidity = ifelse(FixedAcidity > 16, NA, FixedAcidity),
    FreeSulfurDioxide = ifelse(FreeSulfurDioxide > 350, NA, FreeSulfurDioxide),
    TotalSulfurDioxide = ifelse(TotalSulfurDioxide > 350, NA, TotalSulfurDioxide)
  )

summary(wine_training_data)

wine_evaluation_data <- wine_evaluation_data %>%
  mutate(
    FixedAcidity = ifelse(FixedAcidity > 16, NA, FixedAcidity),
    FreeSulfurDioxide = ifelse(FreeSulfurDioxide > 350, NA, FreeSulfurDioxide),
    TotalSulfurDioxide = ifelse(TotalSulfurDioxide > 350, NA, TotalSulfurDioxide)
  )
```
### Imputation of Variables
For the continuous variables, we employed Predictive Mean Matching (PMM) using the mice package. PMM is particularly well-suited for continuous data as it preserves the original data distribution and effectively handles non-normality and skewed distributions. This makes it ideal when maintaining the natural variability of the data is important.

For the ordinal variable `STARS`, we used the polr method (proportional odds logistic regression), which is appropriate for ordered categorical data and assumes the proportional odds assumption—a reasonable assumption for many rating-based variables.

We set the number of imputations to m = 5, which is a commonly used and computationally efficient choice for large datasets. The algorithm was run for maxit = 10 iterations to promote convergence and adequately capture the uncertainty inherent in the imputed values.
```{r, echo=FALSE, message=FALSE}
#| fig-height: 5
#| fig-width: 10
# mice imputation
input_training = wine_training_data
method_vector_train <- c("", "pmm", "", "", "pmm",
                   "pmm", "pmm", "pmm", "", "pmm",
                   "pmm", "pmm", "", "", "polr"
                   )
mice_imp_train = mice(input_training, m = 5, 
                       method = method_vector_train)
summary(input_training$FixedAcidity)
mice_imp_train$imp$FixedAcidity
clean_wine_training_data <- complete(mice_imp_train, 3)
summary(clean_wine_training_data)
plot_histogram(clean_wine_training_data)
plot_density(clean_wine_training_data)
plot_boxplot(clean_wine_training_data, by="TARGET")
plot_bar(clean_wine_training_data)

# do the same for evaluation data
input_evaluation = wine_evaluation_data
method_vector_eval <- c("", "pmm", "", "", "pmm",
                   "pmm", "pmm", "pmm", "", "pmm",
                   "pmm", "pmm", "", "", "polr"
                   )
mice_imp_eval <- mice(input_evaluation, m = 5, 
                       method = method_vector_eval)
clean_wine_evaluation_data <- complete(mice_imp_eval, 3)
```

### Creating missing value flags for all variables

```{r, echo=FALSE}
# missing value flags for training data
clean_wine_training_data <- clean_wine_training_data %>%
  mutate(
    FixedAcidity_NA = ifelse(is.na(wine_training_data$FixedAcidity), 1, 0),
    VolatileAcidity_NA = ifelse(is.na(wine_training_data$VolatileAcidity), 1, 0),
    CitricAcid_NA = ifelse(is.na(wine_training_data$CitricAcid), 1, 0),
    ResidualSugar_NA = ifelse(is.na(wine_training_data$ResidualSugar), 1, 0),
    Chlorides_NA = ifelse(is.na(wine_training_data$Chlorides), 1, 0),
    FreeSulfurDioxide_NA = ifelse(is.na(wine_training_data$FreeSulfurDioxide), 1, 0),
    TotalSulfurDioxide_NA = ifelse(is.na(wine_training_data$TotalSulfurDioxide), 1, 0),
    Density_NA = ifelse(is.na(wine_training_data$Density), 1, 0),
    pH_NA = ifelse(is.na(wine_training_data$pH), 1, 0),
    Sulphates_NA = ifelse(is.na(wine_training_data$Sulphates), 1, 0),
    Alcohol_NA = ifelse(is.na(wine_training_data$Alcohol), 1, 0),
    STARS_NA = ifelse(is.na(wine_training_data$STARS), 1, 0)
  )

# missing value flags for evaluation data
clean_wine_evaluation_data <- clean_wine_evaluation_data %>%
  mutate(
    FixedAcidity_NA = ifelse(is.na(wine_evaluation_data$FixedAcidity), 1, 0),
    VolatileAcidity_NA = ifelse(is.na(wine_evaluation_data$VolatileAcidity), 1, 0),
    CitricAcid_NA = ifelse(is.na(wine_evaluation_data$CitricAcid), 1, 0),
    ResidualSugar_NA = ifelse(is.na(wine_evaluation_data$ResidualSugar), 1, 0),
    Chlorides_NA = ifelse(is.na(wine_evaluation_data$Chlorides), 1, 0),
    FreeSulfurDioxide_NA = ifelse(is.na(wine_evaluation_data$FreeSulfurDioxide), 1, 0),
    TotalSulfurDioxide_NA = ifelse(is.na(wine_evaluation_data$TotalSulfurDioxide), 1, 0),
    Density_NA = ifelse(is.na(wine_evaluation_data$Density), 1, 0),
    pH_NA = ifelse(is.na(wine_evaluation_data$pH), 1, 0),
    Sulphates_NA = ifelse(is.na(wine_evaluation_data$Sulphates), 1, 0),
    Alcohol_NA = ifelse(is.na(wine_evaluation_data$Alcohol), 1, 0),
    STARS_NA = ifelse(is.na(wine_evaluation_data$STARS), 1, 0)
  )

cat("Summary of missing value flags in training data:\n")
summary(clean_wine_training_data %>% select(ends_with("_NA")))

cat("Missing value patterns in training data:\n")
plot_missing(clean_wine_training_data %>% select(ends_with("_NA")))
```
```{r, echo=FALSE}

# Calculate percentage of missing values for each variable
missing_percentages <- clean_wine_training_data %>%
  select(ends_with("_NA")) %>%
  summarise(across(everything(), ~mean(.) * 100)) %>%
  pivot_longer(everything(), names_to = "Variable", values_to = "Percentage") %>%
  mutate(Variable = str_remove(Variable, "_NA"))

# Print missing value percentages
print(missing_percentages)

# Visualize missing value percentages
ggplot(missing_percentages, aes(x = reorder(Variable, -Percentage), y = Percentage)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  geom_text(aes(label = sprintf("%.1f%%", Percentage)), vjust = -0.5) +
  labs(title = "Percentage of Missing Values by Variable",
       x = "Variable",
       y = "Percentage Missing") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```
### **Analysis of Missing Value Patterns**

An examination of missing values in the training dataset reveals the following insights:

- **Highest Missing Rates**:
  - **STARS** has the most missing data, with approximately **26.25%** missing entries.
  - **TotalSulfurDioxide** follows closely, with **21.2%** missing.
  - Other variables with notable missingness include **Sulphates (9.46%)**, **FixedAcidity (9.30%)**, and **FreeSulfurDioxide (7.93%)**.

- **Moderate Missing Rates (3–5%)**:
  - **Alcohol**: 5.10% missing
  - **ResidualSugar**: 4.81% missing
  - **Chlorides**: 4.99% missing
  - **pH**: 3.09% missing

- **No Missing Values**:
  - **VolatileAcidity**, **CitricAcid**, and **Density** are fully observed with no missing data.

- **Observed Patterns**:
  - **Chemical measurements** (e.g., TotalSulfurDioxide, FreeSulfurDioxide) tend to have higher rates of missingness.
  - **Quality indicators** like **STARS** show the highest missingness overall.
  - **Basic compositional features** such as **VolatileAcidity** and **CitricAcid** appear to be reliably measured.

In summary, only a few features require special handling for missing data, particularly those related to sulfur content, acidity, and quality scores.

Perfect — here's the cleaner, **non-repetitive** version you can paste after your missing value patterns section:

### **Missing Data Completion**

Building on the missing value analysis, we completed the remaining missing entries to prepare the dataset for modeling. While earlier imputations handled most gaps, a small number of missing values persisted, particularly among chemical composition variables.

To finalize the dataset:
- We performed another round of multiple imputation using the **mice** package, ensuring complete and consistent records across all features.
- The final imputation filled any residual missing values while preserving the original data distribution and avoiding unnecessary information loss.

The final clean dataset was generated with the following code:

```{r, echo=FALSE}
library(mice)

# Re-run mice on wine_training_data
input_training <- wine_training_data

method_vector_train <- c("", "pmm", "", "", "pmm",
                         "pmm", "pmm", "pmm", "", "pmm",
                         "pmm", "pmm", "", "", "polr")

# mice imputation
mice_imp_train <- mice(input_training, m = 5, method = method_vector_train, maxit = 10)

# complete the dataset
clean_wine_training_data <- complete(mice_imp_train, 3)

summary(clean_wine_training_data)
```
After applying missing value imputation and removing extreme outliers, the dataset no longer contains missing values across any of the key continuous or categorical variables.

With missing values addressed, we proceed to transform continuous variables into categorical buckets to support easier analysis and modeling.

### Transforming data by putting it into buckets

With the dataset fully cleaned and missing values addressed, we now transform key continuous variables into categorical buckets based on domain knowledge (e.g., wine acidity ranges, sugar levels). This binning simplifies complex distributions and enables easier pattern discovery across different chemical properties of wine.
```{r, echo=FALSE}
library(ggplot2)
library(patchwork)
library(stringr)
library(dplyr)

# buckets for continuous variables
clean_wine_training_data <- clean_wine_training_data %>%
  mutate(
    # FixedAcidity buckets (typical range: 4-16 g/L)
    FixedAcidity_bucket = cut(FixedAcidity, 
                            breaks = c(-Inf, 4, 6, 8, 10, 12, 14, 16, Inf),
                            labels = c("Very Low", "Low", "Medium-Low", "Medium", 
                                     "Medium-High", "High", "Very High", "Extreme")),
    
    # VolatileAcidity buckets (typical range: 0.2-1.0 g/L)
    VolatileAcidity_bucket = cut(VolatileAcidity,
                               breaks = c(-Inf, 0.2, 0.4, 0.6, 0.8, 1.0, Inf),
                               labels = c("Very Low", "Low", "Medium", "High", 
                                        "Very High", "Extreme")),
    
    # CitricAcid buckets (typical range: 0-1 g/L)
    CitricAcid_bucket = cut(CitricAcid,
                          breaks = c(-Inf, 0.2, 0.4, 0.6, 0.8, 1.0, Inf),
                          labels = c("Very Low", "Low", "Medium", "High", 
                                   "Very High", "Extreme")),
    
    # ResidualSugar buckets (typical range: 0-50 g/L)
    ResidualSugar_bucket = cut(ResidualSugar,
                             breaks = c(-Inf, 1, 5, 10, 20, 30, 50, Inf),
                             labels = c("Bone Dry", "Dry", "Off-Dry", "Medium", 
                                      "Medium-Sweet", "Sweet", "Very Sweet")),
    
    # Chlorides buckets (typical range: 0.01-0.1 g/L)
    Chlorides_bucket = cut(Chlorides,
                         breaks = c(-Inf, 0.01, 0.03, 0.05, 0.07, 0.1, Inf),
                         labels = c("Very Low", "Low", "Medium", "High", 
                                  "Very High", "Extreme")),
    
    # FreeSulfurDioxide buckets (typical range: 0-350 mg/L)
    FreeSulfurDioxide_bucket = cut(FreeSulfurDioxide,
                                 breaks = c(-Inf, 10, 30, 50, 100, 200, 350, Inf),
                                 labels = c("Very Low", "Low", "Medium", "High", 
                                          "Very High", "Extreme", "Excessive")),
    
    # TotalSulfurDioxide buckets (typical range: 0-350 mg/L)
    TotalSulfurDioxide_bucket = cut(TotalSulfurDioxide,
                                  breaks = c(-Inf, 30, 100, 150, 200, 300, 350, Inf),
                                  labels = c("Very Low", "Low", "Medium", "High", 
                                           "Very High", "Extreme", "Excessive")),
    
    # Density buckets (typical range: 0.98-1.01 g/cm³)
    Density_bucket = cut(Density,
                       breaks = c(-Inf, 0.98, 0.99, 0.995, 1.0, 1.005, 1.01, Inf),
                       labels = c("Very Light", "Light", "Medium-Light", "Medium", 
                                "Medium-Heavy", "Heavy", "Very Heavy")),
    
    # pH buckets (typical range: 2.8-4.0)
    pH_bucket = cut(pH,
                   breaks = c(-Inf, 2.8, 3.0, 3.2, 3.4, 3.6, 3.8, 4.0, Inf),
                   labels = c("Very Acidic", "Acidic", "Medium-Acidic", "Medium", 
                            "Medium-Basic", "Basic", "Very Basic", "Extreme")),
    
    # Sulphates buckets (typical range: 0.3-1.0 g/L)
    Sulphates_bucket = cut(Sulphates,
                         breaks = c(-Inf, 0.3, 0.5, 0.7, 0.9, 1.0, Inf),
                         labels = c("Very Low", "Low", "Medium", "High", 
                                  "Very High", "Extreme")),
    
    # Alcohol buckets (typical range: 8-15%)
    Alcohol_bucket = cut(Alcohol,
                       breaks = c(-Inf, 8, 10, 12, 13, 14, 15, Inf),
                       labels = c("Very Low", "Low", "Medium", "Medium-High", 
                                "High", "Very High", "Extreme")),
    
    # AcidIndex buckets (typical range: 4-10)
    AcidIndex_bucket = cut(AcidIndex,
                         breaks = c(-Inf, 4, 6, 8, 10, Inf),
                         labels = c("Very Low", "Low", "Medium", "High", "Very High"))
  )

# doing the same for evaluation data
clean_wine_evaluation_data <- clean_wine_evaluation_data %>%
  mutate(
    FixedAcidity_bucket = cut(FixedAcidity, 
                            breaks = c(-Inf, 4, 6, 8, 10, 12, 14, 16, Inf),
                            labels = c("Very Low", "Low", "Medium-Low", "Medium", 
                                     "Medium-High", "High", "Very High", "Extreme")),
    VolatileAcidity_bucket = cut(VolatileAcidity,
                               breaks = c(-Inf, 0.2, 0.4, 0.6, 0.8, 1.0, Inf),
                               labels = c("Very Low", "Low", "Medium", "High", 
                                        "Very High", "Extreme")),
    CitricAcid_bucket = cut(CitricAcid,
                          breaks = c(-Inf, 0.2, 0.4, 0.6, 0.8, 1.0, Inf),
                          labels = c("Very Low", "Low", "Medium", "High", 
                                   "Very High", "Extreme")),
    ResidualSugar_bucket = cut(ResidualSugar,
                             breaks = c(-Inf, 1, 5, 10, 20, 30, 50, Inf),
                             labels = c("Bone Dry", "Dry", "Off-Dry", "Medium", 
                                      "Medium-Sweet", "Sweet", "Very Sweet")),
    Chlorides_bucket = cut(Chlorides,
                         breaks = c(-Inf, 0.01, 0.03, 0.05, 0.07, 0.1, Inf),
                         labels = c("Very Low", "Low", "Medium", "High", 
                                  "Very High", "Extreme")),
    FreeSulfurDioxide_bucket = cut(FreeSulfurDioxide,
                                 breaks = c(-Inf, 10, 30, 50, 100, 200, 350, Inf),
                                 labels = c("Very Low", "Low", "Medium", "High", 
                                          "Very High", "Extreme", "Excessive")),
    TotalSulfurDioxide_bucket = cut(TotalSulfurDioxide,
                                  breaks = c(-Inf, 30, 100, 150, 200, 300, 350, Inf),
                                  labels = c("Very Low", "Low", "Medium", "High", 
                                           "Very High", "Extreme", "Excessive")),
    Density_bucket = cut(Density,
                       breaks = c(-Inf, 0.98, 0.99, 0.995, 1.0, 1.005, 1.01, Inf),
                       labels = c("Very Light", "Light", "Medium-Light", "Medium", 
                                "Medium-Heavy", "Heavy", "Very Heavy")),
    pH_bucket = cut(pH,
                   breaks = c(-Inf, 2.8, 3.0, 3.2, 3.4, 3.6, 3.8, 4.0, Inf),
                   labels = c("Very Acidic", "Acidic", "Medium-Acidic", "Medium", 
                            "Medium-Basic", "Basic", "Very Basic", "Extreme")),
    Sulphates_bucket = cut(Sulphates,
                         breaks = c(-Inf, 0.3, 0.5, 0.7, 0.9, 1.0, Inf),
                         labels = c("Very Low", "Low", "Medium", "High", 
                                  "Very High", "Extreme")),
    Alcohol_bucket = cut(Alcohol,
                       breaks = c(-Inf, 8, 10, 12, 13, 14, 15, Inf),
                       labels = c("Very Low", "Low", "Medium", "Medium-High", 
                                "High", "Very High", "Extreme")),
    AcidIndex_bucket = cut(AcidIndex,
                         breaks = c(-Inf, 4, 6, 8, 10, Inf),
                         labels = c("Very Low", "Low", "Medium", "High", "Very High"))
  )

# summary of bucket distributions
cat("Distribution of buckets for key variables:\n")
summary(dplyr::select(clean_wine_training_data, ends_with("_bucket")))

bucket_vars <- names(clean_wine_training_data %>% dplyr::select(dplyr::ends_with("_bucket")))

# plots
bucket_plots <- lapply(bucket_vars, function(var) {
  ggplot(clean_wine_training_data, aes_string(x = var)) +
    geom_bar(fill = "steelblue") +
    labs(title = str_replace(var, "_bucket", ""), x = NULL, y = NULL) +
    theme_minimal() +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1, size = 7),
      plot.title = element_text(size = 10, face = "bold", hjust = 0.5),
      plot.margin = margin(5, 5, 5, 5)
    )
})

wrap_plots(bucket_plots, ncol = 4) + 
  plot_annotation(
    title = "Distributions of Wine Features by Category",
    theme = theme(
      plot.title = element_text(size = 14, face = "bold", hjust = 0.5)
    )
  )
```
To better understand variable distributions, we grouped continuous features into descriptive categories:

- **FixedAcidity** is concentrated in the *"Medium-Low"* (4,943 wines) and *"Very Low"* (2,536 wines) buckets.
- **VolatileAcidity** shows a bimodal pattern, dominated by *"Low"* (4,325 wines) and *"Extreme"* (2,780 wines).
- **CitricAcid** is mainly *"Low"* (4,339 wines) and *"Extreme"* (3,054 wines), with fewer wines in intermediate categories.
- **ResidualSugar** is fairly spread, with most wines in *"Dry"* (3,518), *"Sweet"* (2,050), and *"Very Sweet"* (2,034) buckets.
- **Chlorides** are overwhelmingly in the *"Extreme"* bucket (6,368 wines), suggesting strong skewness.
- **FreeSulfurDioxide** and **TotalSulfurDioxide** are centered between *"Low"* to *"Very High"*, with *"Low"* (~2,800 wines each) and *"Very High"* (~2,400 wines) being the most common.
- **Density** is concentrated in *"Medium-Light"* (3,065 wines), *"Medium"* (2,763), and *"Very Heavy"* (2,520).
- **pH** clusters around *"Medium-Acidic"* (2,969), *"Medium"* (2,664), and *"Very Acidic"* (2,587), showing diverse acidity levels.
- **Sulphates** are mostly in the *"Low"* (3,536) and *"Medium"* (2,875) ranges, but there's a significant spike in *"Extreme"* (3,509 wines).
- **Alcohol** is evenly distributed between *"Low"* (3,406), *"Medium"* (3,445), and *"Medium-High"* (1,118).
- **AcidIndex** is heavily skewed to *"Medium"* (9,020 wines), clearly dominating that feature.

These bucketed distributions help reveal central tendencies and detect skewed variables or potential outliers, improving clarity for downstream modeling or classification strategies.

### Applying mathematical transformations to continuous variables
```{r, echo=FALSE}
library(MASS)
library(dplyr)

# saving lambdas globally for Box-Cox
boxcox_results <- list()

apply_boxcox <- function(x, var_name) {
  x_adj <- x + 1  # shifting to ensure positivity
  if (all(x_adj > 0, na.rm = TRUE)) {
    bc <- boxcox(x_adj ~ 1, plotit = FALSE)
    lambda <- bc$x[which.max(bc$y)]
    boxcox_results[[var_name]] <<- lambda
    
    if (abs(lambda) < 1e-10) {
      return(log(x_adj))
    } else {
      return((x_adj^lambda - 1) / lambda)
    }
  } else {
    boxcox_results[[var_name]] <<- NA
    return(rep(NA, length(x)))
  }
}

# transformations to training data
clean_wine_training_data <- clean_wine_training_data %>%
  mutate(
    # Log
    log_FixedAcidity = log(FixedAcidity + 1),
    log_VolatileAcidity = log(VolatileAcidity + 1),
    log_CitricAcid = log(CitricAcid + 1),
    log_ResidualSugar = log(ResidualSugar + 1),
    log_Chlorides = log(Chlorides + 1),
    log_FreeSulfurDioxide = log(FreeSulfurDioxide + 1),
    log_TotalSulfurDioxide = log(TotalSulfurDioxide + 1),
    log_Sulphates = log(Sulphates + 1),
    log_Alcohol = log(Alcohol + 1),
    log_AcidIndex = log(AcidIndex + 1),
    
    # Square Root
    sqrt_FixedAcidity = sqrt(FixedAcidity),
    sqrt_VolatileAcidity = sqrt(VolatileAcidity),
    sqrt_CitricAcid = sqrt(CitricAcid),
    sqrt_ResidualSugar = sqrt(ResidualSugar),
    sqrt_Chlorides = sqrt(Chlorides),
    sqrt_FreeSulfurDioxide = sqrt(FreeSulfurDioxide),
    sqrt_TotalSulfurDioxide = sqrt(TotalSulfurDioxide),
    sqrt_Sulphates = sqrt(Sulphates),
    sqrt_Alcohol = sqrt(Alcohol),
    sqrt_AcidIndex = sqrt(AcidIndex),
    
    # Box-Cox
    boxcox_FixedAcidity = apply_boxcox(FixedAcidity, "FixedAcidity"),
    boxcox_VolatileAcidity = apply_boxcox(VolatileAcidity, "VolatileAcidity"),
    boxcox_CitricAcid = apply_boxcox(CitricAcid, "CitricAcid"),
    boxcox_ResidualSugar = apply_boxcox(ResidualSugar, "ResidualSugar"),
    boxcox_Chlorides = apply_boxcox(Chlorides, "Chlorides"),
    boxcox_FreeSulfurDioxide = apply_boxcox(FreeSulfurDioxide, "FreeSulfurDioxide"),
    boxcox_TotalSulfurDioxide = apply_boxcox(TotalSulfurDioxide, "TotalSulfurDioxide"),
    boxcox_Sulphates = apply_boxcox(Sulphates, "Sulphates"),
    boxcox_Alcohol = apply_boxcox(Alcohol, "Alcohol"),
    boxcox_AcidIndex = apply_boxcox(AcidIndex, "AcidIndex")
  )

# applying Box-Cox to evaluation data using saved lambdas
apply_boxcox_eval <- function(x, var_name) {
  lambda <- boxcox_results[[var_name]]
  x_adj <- x + 1
  if (is.na(lambda)) {
    return(rep(NA, length(x)))
  } else if (abs(lambda) < 1e-10) {
    return(log(x_adj))
  } else {
    return((x_adj^lambda - 1) / lambda)
  }
}

clean_wine_evaluation_data <- clean_wine_evaluation_data %>%
  mutate(
    boxcox_FixedAcidity = apply_boxcox_eval(FixedAcidity, "FixedAcidity"),
    boxcox_VolatileAcidity = apply_boxcox_eval(VolatileAcidity, "VolatileAcidity"),
    boxcox_CitricAcid = apply_boxcox_eval(CitricAcid, "CitricAcid"),
    boxcox_ResidualSugar = apply_boxcox_eval(ResidualSugar, "ResidualSugar"),
    boxcox_Chlorides = apply_boxcox_eval(Chlorides, "Chlorides"),
    boxcox_FreeSulfurDioxide = apply_boxcox_eval(FreeSulfurDioxide, "FreeSulfurDioxide"),
    boxcox_TotalSulfurDioxide = apply_boxcox_eval(TotalSulfurDioxide, "TotalSulfurDioxide"),
    boxcox_Sulphates = apply_boxcox_eval(Sulphates, "Sulphates"),
    boxcox_Alcohol = apply_boxcox_eval(Alcohol, "Alcohol"),
    boxcox_AcidIndex = apply_boxcox_eval(AcidIndex, "AcidIndex")
  )

# summary after transformations
clean_wine_training_data %>%
  dplyr::select(starts_with("log_"), starts_with("sqrt_"), starts_with("boxcox_")) %>%
  summary()
```

### **Interpretation of Transformed Variable Summary Statistics**

The application of logarithmic and square root transformations noticeably improved the distribution of several continuous variables.

For instance:  
- **ResidualSugar**  
  - **Before**: Mean = 23.37, Median = 12.90  
  - **After log transform**: Mean = 2.60, Median = 2.63  
  This shows a strong compression toward the center, reducing extreme right skewness.
  
- **TotalSulfurDioxide**  
  - **Before**: Mean = 204.3, Median = 154.0  
  - **After log transform**: Mean = 4.75, Median = 4.91  
  A significant reduction in spread, pulling extreme values closer to the mean.

- **VolatileAcidity**  
  - **Before**: Mean = 0.6411, Median = 0.4100  
  - **After log transform**: Mean = 0.4485, Median = 0.3436  
  The transformation centered the distribution better, reducing the long tail.

Square root transformations also helped in moderating skewness:  
- **Sulphates**  
  - **Before**: Mean = 0.8467, Median = 0.5900  
  - **After sqrt transform**: Mean = 0.8616, Median = 0.7681  
  Indicating a more balanced distribution while retaining original order.

- **Chlorides**  
  - **Before**: Mean = 0.2226, Median = 0.0980  
  - **After sqrt transform**: Mean = 0.4110, Median = 0.3146  
  Showing improvement but still retaining some moderate skewness.

Features like **FixedAcidity** and **Alcohol**, which were relatively symmetric to begin with:  
- **FixedAcidity (log)**: Mean = 1.943, Median = 2.054  
- **Alcohol (log)**: Mean = 2.383, Median = 2.434  
showed only modest normalization, as expected.

Overall, transformations improved the shape and stability of feature distributions, particularly for heavily skewed variables, supporting better model training and convergence.

### **Visual Interpretation of Log-Transformed Distributions**

```{r, echo=FALSE}
library(ggplot2)
library(patchwork)
library(stringr)

# plot
base_vars <- c("FixedAcidity", "VolatileAcidity", "CitricAcid", "ResidualSugar", 
               "Chlorides", "FreeSulfurDioxide", "TotalSulfurDioxide", 
               "Sulphates", "Alcohol", "AcidIndex")

make_hist_plot <- function(var_name, prefix = NULL) {
  colname <- if (is.null(prefix)) var_name else paste0(prefix, "_", var_name)
  display_name <- if (is.null(prefix)) paste0("Original: ", var_name) else paste0(prefix, ": ", var_name)
  
  if (colname %in% names(clean_wine_training_data) && is.numeric(clean_wine_training_data[[colname]])) {
    ggplot(clean_wine_training_data, aes(x = .data[[colname]])) +
      geom_histogram(bins = 30, fill = "#4c72b0", color = "white", na.rm = TRUE) +
      labs(title = display_name, x = NULL, y = NULL) +
      theme_minimal() +
      theme(
        plot.title = element_text(size = 10, face = "bold"),
        axis.text.x = element_text(size = 6)
      )
  } else {
    NULL
  }
}

for (var in base_vars) {
  plots <- list(
    make_hist_plot(var),
    make_hist_plot(var, "log"),
    make_hist_plot(var, "sqrt"),
    make_hist_plot(var, "boxcox")
  )
  plots <- plots[!sapply(plots, is.null)]
  
  print(
    wrap_plots(plots, ncol = 2) + 
      plot_annotation(title = paste("Distribution Comparison for", var))
  )
}
```
The application of log, square root, and Box-Cox transformations improved the distribution of several continuous variables, particularly those with strong right skew such as `ResidualSugar`, `FreeSulfurDioxide`, and `TotalSulfurDioxide`. These transformations reduced outlier influence, compressed long tails, and brought distributions closer to normality—key for meeting model assumptions and enhancing predictive stability. Moderately skewed variables like `CitricAcid`, `Chlorides`, and `Sulphates` also became more balanced, with Box-Cox offering smoother distributional adjustments in most cases. Variables that were already near-normal, such as `Alcohol` and `AcidIndex`, showed minimal shifts post-transformation. Overall, these preprocessing steps contribute to more robust and interpretable modeling outcomes.

### **Combine variables**

To further enrich the dataset and capture meaningful chemical relationships, we engineered new features by combining and transforming existing variables. These derived features, such as acidity ratios and sulfur-to-acid balances, aim to enhance model performance by embedding domain knowledge directly into the feature set.
```{r, echo=FALSE}
library(ggplot2)
library(patchwork)

# combining variables based on wine chemistry relationships
clean_wine_training_data <- clean_wine_training_data %>%
  mutate(
    # Core chemical combinations
    TotalAcidity = FixedAcidity + VolatileAcidity + CitricAcid,
    
    # Key ratios with NA handling for zero divisions
    AcidityRatio = ifelse(VolatileAcidity > 0, FixedAcidity / VolatileAcidity, NA),
    CitricToFixedRatio = ifelse(FixedAcidity > 0, CitricAcid / FixedAcidity, NA),
    FreeToTotalSulfurRatio = ifelse(TotalSulfurDioxide > 0, FreeSulfurDioxide / TotalSulfurDioxide, NA),
    SulfurToAcidRatio = TotalSulfurDioxide / TotalAcidity,
    AlcoholToSugarRatio = ifelse(ResidualSugar > 0, Alcohol / ResidualSugar, NA),
    
    # Mineral and pH relationships
    SulfateToChlorideRatio = ifelse(Chlorides > 0, Sulphates / Chlorides, NA),
    pHToAcidityRatio = pH / TotalAcidity
  )

# transformations to evaluation data
clean_wine_evaluation_data <- clean_wine_evaluation_data %>%
  mutate(
    TotalAcidity = FixedAcidity + VolatileAcidity + CitricAcid,
    AcidityRatio = ifelse(VolatileAcidity > 0, FixedAcidity / VolatileAcidity, NA),
    CitricToFixedRatio = ifelse(FixedAcidity > 0, CitricAcid / FixedAcidity, NA),
    FreeToTotalSulfurRatio = ifelse(TotalSulfurDioxide > 0, FreeSulfurDioxide / TotalSulfurDioxide, NA),
    SulfurToAcidRatio = TotalSulfurDioxide / TotalAcidity,
    AlcoholToSugarRatio = ifelse(ResidualSugar > 0, Alcohol / ResidualSugar, NA),
    SulfateToChlorideRatio = ifelse(Chlorides > 0, Sulphates / Chlorides, NA),
    pHToAcidityRatio = pH / TotalAcidity
  )

# engineered variables
engineered_vars <- c(
  "TotalAcidity", "AcidityRatio", "CitricToFixedRatio",
  "FreeToTotalSulfurRatio", "SulfurToAcidRatio",
  "AlcoholToSugarRatio", "SulfateToChlorideRatio",
  "pHToAcidityRatio"
)

# histogram plots for each engineered variable
engineered_plots <- lapply(engineered_vars, function(v) {
  ggplot(clean_wine_training_data, aes(x = .data[[v]])) +
    geom_histogram(bins = 30, fill = "#4c72b0", na.rm = TRUE) +
    labs(title = v, x = NULL, y = NULL) +
    theme_minimal() +
    theme(
      plot.title = element_text(size = 9, face = "bold"),
      axis.text.x = element_text(size = 6)
    )
})

wrap_plots(engineered_plots, ncol = 3) +
  plot_annotation(title = "Distributions of Engineered Features")

# summary
summary(clean_wine_training_data)
```
### **Summary Statistics and Feature Insights**

The dataset covers 12,795 wine samples with a target variable (`TARGET`) ranging from 0 to 8 (mean: 3.03, median: 3), indicating a relatively balanced rating distribution.

Several features exhibited strong right skewness, including:
- **ResidualSugar** (max: 141.15, Q3: 38.6),
- **Chlorides** (max: 1.35, Q3: 0.368),
- **FreeSulfurDioxide** (max: 350, Q3: 158),
- **Sulphates** (max: 4.24, Q3: 1.10).

Logarithmic and square root transformations were applied, successfully normalizing these variables. For example, the transformed `log_ResidualSugar` (mean: 2.60) and `sqrt_ResidualSugar` (mean: 4.14) showed significantly improved distribution shapes. Box-Cox transformations were also successfully applied and retained for modeling.

Domain-informed feature engineering further enhanced the dataset:
- **AcidityRatio** (mean: 24.26, max: 1420),
- **AlcoholToSugarRatio** (mean: 2.27),
- **SulfateToChlorideRatio** (mean: 12.76, max: 1260).

These engineered ratios captured important interaction effects between acidity, sugar, minerals, and alcohol content, enriching the dataset for predictive modeling.

Lastly, missing data was observed primarily in `STARS` (~26%), `TotalSulfurDioxide` (~21%), and `pH` (~3%). Missingness flags were created to preserve information for downstream machine learning models.

### Final data check before modeling
```{r, echo=FALSE}
# Final data check before modeling
cat("Final Data Check:\n")

# 1. checking for remaining missing values
cat("\n1. Missing Values Check:\n")
missing_check <- sapply(clean_wine_training_data, function(x) sum(is.na(x)))
print(missing_check[missing_check > 0])

# 2. verify data types
cat("\n2. Data Types Check:\n")
str(clean_wine_training_data)

# 3. check for extreme values
cat("\n3. Extreme Values Check:\n")
summary(clean_wine_training_data)

# 4. verify bucket distributions
cat("\n4. Bucket Distributions Check:\n")
bucket_vars <- names(clean_wine_training_data %>% dplyr::select(dplyr::ends_with("_bucket")))
for(var in bucket_vars) {
  cat("\n", var, "distribution:\n")
  print(table(clean_wine_training_data[[var]], useNA = "ifany"))
}

# 5. Prepare data for modeling
cat("\n5. Preparing Data for Modeling:\n")
# Select only the variables needed for modeling
final_training_data <- clean_wine_training_data %>%
  dplyr::select(
    TARGET, 
    STARS, 
    LabelAppeal, 
    Alcohol, 
    TotalSulfurDioxide, 
    FreeSulfurDioxide, 
    ResidualSugar, 
    pH, 
    AcidIndex,
    starts_with("log_"),
    TotalAcidity, 
    AcidityRatio, 
    SulfurToAcidRatio, 
    AlcoholToSugarRatio, 
    pHToAcidityRatio
  )

# Handle problematic values in the enhanced model variables
cat("\nHandling problematic values in enhanced model variables:\n")
problem_vars <- c("log_Alcohol", "log_TotalSulfurDioxide", "log_FreeSulfurDioxide", 
                 "log_ResidualSugar", "TotalAcidity", "AcidityRatio", 
                 "SulfurToAcidRatio", "AlcoholToSugarRatio", "pHToAcidityRatio")

# Check for NA, NaN, and Inf values
for(var in problem_vars) {
  cat("\nChecking", var, ":\n")
  cat("NA count:", sum(is.na(final_training_data[[var]])), "\n")
  cat("NaN count:", sum(is.nan(final_training_data[[var]])), "\n")
  cat("Inf count:", sum(is.infinite(final_training_data[[var]])), "\n")
}

# Clean problematic values and ensure all variables are numeric
final_training_data <- final_training_data %>%
  mutate(
    # Replace Inf with NA for ratio variables
    AcidityRatio = ifelse(is.infinite(AcidityRatio), NA, AcidityRatio),
    SulfurToAcidRatio = ifelse(is.infinite(SulfurToAcidRatio), NA, SulfurToAcidRatio),
    AlcoholToSugarRatio = ifelse(is.infinite(AlcoholToSugarRatio), NA, AlcoholToSugarRatio),
    pHToAcidityRatio = ifelse(is.infinite(pHToAcidityRatio), NA, pHToAcidityRatio),
    
    # Ensure log-transformed variables are valid
    log_Alcohol = ifelse(is.na(log_Alcohol) | is.infinite(log_Alcohol), 
                        log(Alcohol + 1), log_Alcohol),
    log_TotalSulfurDioxide = ifelse(is.na(log_TotalSulfurDioxide) | is.infinite(log_TotalSulfurDioxide), 
                                   log(TotalSulfurDioxide + 1), log_TotalSulfurDioxide),
    log_FreeSulfurDioxide = ifelse(is.na(log_FreeSulfurDioxide) | is.infinite(log_FreeSulfurDioxide), 
                                  log(FreeSulfurDioxide + 1), log_FreeSulfurDioxide),
    log_ResidualSugar = ifelse(is.na(log_ResidualSugar) | is.infinite(log_ResidualSugar), 
                              log(ResidualSugar + 1), log_ResidualSugar),
    
    # Ensure all variables are numeric
    across(all_of(problem_vars), as.numeric)
  )

# Final imputation for any remaining NA values
cat("\nPerforming final imputation for remaining NA values:\n")
imputed_data <- mice(final_training_data, m=1, maxit=50, method='pmm', seed=500)
final_training_data <- complete(imputed_data)

# Verify all problematic values are handled
cat("\nVerifying problematic values are handled:\n")
for(var in problem_vars) {
  cat("\nChecking", var, "after cleaning:\n")
  cat("NA count:", sum(is.na(final_training_data[[var]])), "\n")
  cat("NaN count:", sum(is.nan(final_training_data[[var]])), "\n")
  cat("Inf count:", sum(is.infinite(final_training_data[[var]])), "\n")
}

# Save evaluation data
final_evaluation_data <- clean_wine_evaluation_data

cat("\nData preparation complete. Datasets are ready for modeling.\n")
```

After reviewing the final data check, we can proceed with modeling as the dataset is in good shape: while there are some minor NAs in engineered ratios (18-42 cases out of 12,795 observations) and extreme values in ratio variables, these are expected outcomes of chemical relationships in wine and won't significantly impact model performance. The core variables have been properly transformed, bucket distributions are reasonable, and all data types are correct. 

The dataset's size (12,795 observations) provides sufficient data for robust modeling, and the time investment needed for additional cleaning would likely yield only marginal improvements. Therefore, we're ready to proceed with the modeling phase, where we can address any specific issues that might arise during model development.

## **Build Models**
## **Poisson Regression Models**

Since our target variable `TARGET` represents the number of wine cases purchased (a count variable), Poisson regression is an appropriate choice. We'll build two different models focusing on the key factors that influence wine sales:

1. A basic model using the most influential variables based on business context
2. An enhanced model incorporating transformed variables and additional chemical interactions

### **Model 1: Basic Poisson Regression**

To establish a baseline, we fit a Poisson regression model using key predictors identified from the exploratory analysis, including `STARS`, `LabelAppeal`, `Alcohol`, `TotalSulfurDioxide`, `FreeSulfurDioxide`, `ResidualSugar`, `pH`, and `AcidIndex`. This model assumes the Poisson distribution is appropriate for the count-based target variable (`TARGET`).  

```{r, echo=FALSE}
library(MASS)
library(pscl)
library(ggplot2)
library(dplyr)
library(AER)  # Added for dispersiontest

# Fit the basic model
basic_poisson <- glm(TARGET ~ STARS + LabelAppeal + Alcohol + 
                     TotalSulfurDioxide + FreeSulfurDioxide + 
                     ResidualSugar + pH + AcidIndex,
                   data = final_training_data,
                   family = poisson(link = "log"))

# Model summary
cat("Basic Poisson Regression Model Summary:\n")
summary(basic_poisson)

# Check for overdispersion
cat("\nOverdispersion Test for Basic Model:\n")
dispersiontest(basic_poisson)

# Residual plots
par(mfrow = c(2, 2))
plot(basic_poisson, which = 1:4)

# Calculate predictions
predictions_basic <- predict(basic_poisson, type = "response")

# Calculate performance metrics
rmse_basic <- sqrt(mean((final_training_data$TARGET - predictions_basic)^2))
mae_basic <- mean(abs(final_training_data$TARGET - predictions_basic))

cat("\nBasic Model Performance Metrics:\n")
cat("RMSE:", rmse_basic, "\n")
cat("MAE:", mae_basic, "\n")
cat("AIC:", AIC(basic_poisson), "\n")
```
The basic Poisson model shows that `STARS`, `LabelAppeal`, `Alcohol`, `TotalSulfurDioxide`, and `AcidIndex` are statistically significant predictors of the wine rating (`TARGET`), with very small p-values. `ResidualSugar`, `FreeSulfurDioxide`, and `pH` have weaker or borderline effects. The overdispersion test indicates no significant overdispersion (dispersion ≈ 0.89, p-value = 1), suggesting the Poisson model assumptions are acceptable. Model performance metrics (RMSE = 1.39, MAE = 1.13) indicate reasonable prediction accuracy, but there is room for improvement.

### **Model 2: Enhanced Poisson Regression**
After evaluating the basic model, we enhanced the Poisson regression by incorporating log-transformed chemical features and engineered interaction variables. These additions aim to capture nonlinear effects and improve model fit while maintaining interpretability. The following code fits the enhanced model and evaluates its performance.

```{r, echo=FALSE}
# Fit the enhanced model
enhanced_poisson <- glm(TARGET ~ STARS + LabelAppeal + 
                        log_Alcohol + log_TotalSulfurDioxide + 
                        log_FreeSulfurDioxide + log_ResidualSugar + 
                        TotalAcidity + AcidityRatio + 
                        SulfurToAcidRatio + AlcoholToSugarRatio + 
                        pHToAcidityRatio + AcidIndex,
                      data = final_training_data,
                      family = poisson(link = "log"))

# Model summary
cat("Enhanced Poisson Regression Model Summary:\n")
summary(enhanced_poisson)

# Check for overdispersion
cat("\nOverdispersion Test for Enhanced Model:\n")
dispersiontest(enhanced_poisson)

# Residual plots
par(mfrow = c(2, 2))
plot(enhanced_poisson, which = 1:4)

# Calculate predictions
predictions_enhanced <- predict(enhanced_poisson, type = "response")

# Calculate performance metrics
rmse_enhanced <- sqrt(mean((final_training_data$TARGET - predictions_enhanced)^2))
mae_enhanced <- mean(abs(final_training_data$TARGET - predictions_enhanced))

cat("\nEnhanced Model Performance Metrics:\n")
cat("RMSE:", rmse_enhanced, "\n")
cat("MAE:", mae_enhanced, "\n")
cat("AIC:", AIC(enhanced_poisson), "\n")
```
Compared to the basic model, the enhanced Poisson regression achieved lower RMSE (1.395 vs. 1.397), slightly improved MAE (1.133 vs. 1.134), and a meaningful reduction in AIC (47167 vs. 47207). No overdispersion was detected in either model. The improvements, though modest in error metrics, demonstrate that feature engineering and log transformations captured important nonlinear relationships, strengthening the overall model. Therefore, the enhanced model was selected for subsequent analysis.

### **Negative Binomial Regression Models**

While our previous Poisson models showed no significant overdispersion (dispersion ≈ 0.89, p-value = 1), we'll still explore negative binomial regression models for completeness and to verify our findings. This is a good practice in model building - to try different approaches even when we have a good initial model, as it helps validate our results and potentially discover new insights.

We'll build two different models:

1. A basic negative binomial model focusing on key business variables
2. An enhanced negative binomial model incorporating transformed variables and chemical interactions

#### **Model 1: Basic Negative Binomial Regression**
The Negative Binomial model introduces an extra parameter to handle variance separately from the mean, providing additional flexibility. We begin by fitting a basic version of the model using the same predictors as the basic Poisson regression.

```{r, echo=FALSE}
library(MASS)
library(pscl)
library(ggplot2)
library(dplyr)

# Fit the basic negative binomial model
basic_nb <- glm.nb(TARGET ~ STARS + LabelAppeal + Alcohol + 
                    TotalSulfurDioxide + FreeSulfurDioxide + 
                    ResidualSugar + pH + AcidIndex,
                  data = final_training_data)

# Model summary
cat("Basic Negative Binomial Regression Model Summary:\n")
summary(basic_nb)

# Calculate predictions
predictions_basic_nb <- predict(basic_nb, type = "response")

# Calculate performance metrics
rmse_basic_nb <- sqrt(mean((final_training_data$TARGET - predictions_basic_nb)^2))
mae_basic_nb <- mean(abs(final_training_data$TARGET - predictions_basic_nb))

cat("\nBasic Negative Binomial Model Performance Metrics:\n")
cat("RMSE:", rmse_basic_nb, "\n")
cat("MAE:", mae_basic_nb, "\n")
cat("AIC:", AIC(basic_nb), "\n")
```
The basic Negative Binomial model produced results almost identical to the basic Poisson model, with RMSE (1.3972), MAE (1.1342), and AIC (47209) very close to those of the Poisson version. The coefficients and significance levels for key predictors such as STARS, LabelAppeal, Alcohol, and AcidIndex remain consistent, indicating that overdispersion was not a serious issue. The warning on theta estimation suggests that the variance adjustment had little effect, reaffirming that the Poisson assumptions were reasonable for this dataset.

#### **Model 2: Enhanced Negative Binomial Regression**
To build on the basic negative binomial model, we next incorporate transformed variables and engineered chemical interaction features. This enhanced specification allows us to capture potential nonlinearities and complex relationships in the data, improving model flexibility without overcomplicating the structure.

```{r, echo=FALSE}
# Fit the enhanced negative binomial model
enhanced_nb <- glm.nb(TARGET ~ STARS + LabelAppeal + 
                      log_Alcohol + log_TotalSulfurDioxide + 
                      log_FreeSulfurDioxide + log_ResidualSugar + 
                      TotalAcidity + AcidityRatio + 
                      SulfurToAcidRatio + AlcoholToSugarRatio + 
                      pHToAcidityRatio + AcidIndex,
                    data = final_training_data)

# Model summary
cat("Enhanced Negative Binomial Regression Model Summary:\n")
summary(enhanced_nb)

# Calculate predictions
predictions_enhanced_nb <- predict(enhanced_nb, type = "response")

# Calculate performance metrics
rmse_enhanced_nb <- sqrt(mean((final_training_data$TARGET - predictions_enhanced_nb)^2))
mae_enhanced_nb <- mean(abs(final_training_data$TARGET - predictions_enhanced_nb))

cat("\nEnhanced Negative Binomial Model Performance Metrics:\n")
cat("RMSE:", rmse_enhanced_nb, "\n")
cat("MAE:", mae_enhanced_nb, "\n")
cat("AIC:", AIC(enhanced_nb), "\n")
```
The enhanced negative binomial model produced a slight improvement over the basic model, achieving a lower RMSE (1.3950), lower MAE (1.1327), and a reduced AIC (47170). Significant predictors like STARS, LabelAppeal, log_Alcohol, log_TotalSulfurDioxide, and AcidIndex remained strong, while interaction variables like AcidityRatio also contributed meaningfully. Similar to earlier models, the warning on theta estimation suggests minimal overdispersion, confirming that both the Poisson and negative binomial approaches are appropriate for this dataset. Overall, the enhanced model offered a modest but measurable improvement in predictive performance.

